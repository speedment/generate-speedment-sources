package com.speedment.sources.pattern.tuple;

import com.speedment.common.codegen.constant.SimpleType;
import com.speedment.common.codegen.internal.model.value.ReferenceValueImpl;
import com.speedment.common.codegen.model.Class;
import com.speedment.common.codegen.model.*;
import com.speedment.common.tuple.Tuple;
import com.speedment.common.tuple.TupleOfNullables;
import com.speedment.common.tuple.internal.AbstractTuple;
import com.speedment.common.tuple.internal.AbstractTupleOfNullables;
import com.speedment.sources.Pattern;

import java.lang.reflect.Type;
import java.util.Optional;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import static com.speedment.common.codegen.constant.DefaultAnnotationUsage.OVERRIDE;
import static com.speedment.common.codegen.constant.DefaultAnnotationUsage.SUPPRESS_WARNINGS_UNCHECKED;
import static com.speedment.common.codegen.constant.DefaultJavadocTag.AUTHOR;
import static com.speedment.common.codegen.constant.DefaultJavadocTag.PARAM;
import static com.speedment.common.codegen.constant.DefaultType.optional;
import static com.speedment.common.invariant.IntRangeUtil.requireNonNegative;
import com.speedment.common.tuple.MutableTuple;
import com.speedment.common.tuple.internal.AbstractMutableTuple;
import static com.speedment.sources.pattern.tuple.TupleUtil.*;
import static java.util.stream.Collectors.joining;

/**
 *
 * @author Per Minborg
 */
public class TupleImplPattern implements Pattern {

    private final int degree;
    private final TupleType type;

    public TupleImplPattern(int degree, TupleType tupe) {
        this.degree = requireNonNegative(degree);
        this.type = tupe;
    }

    @Override
    public String getClassName() {
        return type.eval(
            tupleImplementationSimpleName(degree),
            tupleOfNullablesImplementationSimpleName(degree),
            mutableTupleImplementationSimpleName(degree)
        );
    }

    @Override
    public String getFullClassName() {
        return type.eval(
            tupleImplementationName(degree),
            tupleOfNullablesImplementationName(degree),
            mutableTupleImplementationName(degree)
        );
    }

    @Override
    public boolean isTestClass() {
        return false;
    }

    @Override
    public ClassOrInterface<?> make(File file) {
        final boolean isMutable = TupleType.MUTABLE.equals(type);
        final boolean isNullable = TupleType.IMMUTABLE_NULLABLE.equals(type);

        switch (type) {
            case IMMUTABLE: {
                file.add(Import.of(Tuple.class));
                break;
            }
            case IMMUTABLE_NULLABLE: {
                file.add(Import.of(TupleOfNullables.class));
                break;
            }
            case MUTABLE: {
                file.add(Import.of(MutableTuple.class)).add(Import.of(Optional.class));
                break;
            }
        }

/*        type.eval(
            file.add(Import.of(Tuple.class)),
            file.add(Import.of(TupleOfNullables.class)),
            file.add(Import.of(MutableTuple.class)).add(Import.of(Optional.class))
        );*/

/*        file.add(Import.of(SimpleType.create(tupleName(degree))));*/


        final Javadoc javadoc = Javadoc.of(
            "An implementation class of a {@link " + type.eval(tupleSimpleName(degree), tupleOfNullablesSimpleName(degree), mutableTupleSimpleName(degree)) + "}.\n"
            + "<p>\n"
            + "Generated by " + getClass().getName())
            .add(AUTHOR.setValue("Per Minborg"));

        IntStream.range(0, degree).forEachOrdered(parameter -> {
            javadoc.add(PARAM.setValue("<" + genericTypeName(parameter) + ">").setText("type of element " + parameter));
        });

        final Class clazz = Class.of(getClassName())
            .public_().final_()
            .set(javadoc)
            .setSupertype(type.eval(AbstractTuple.class, AbstractTupleOfNullables.class, AbstractMutableTuple.class))
            .add(type.eval(tupleGenericType(degree), tupleOfNullablesGenericType(degree), mutableTupleGenericType(degree)));

        IntStream.range(0, degree).forEachOrdered(parameter -> {
            clazz.add(Generic.of(genericTypeName(parameter)));
        });

        final Constructor constructor = Constructor.of();
        if (degree == 0) {
            clazz.add(
                Field.of(
                    "EMPTY_TUPLE",
                    type.eval(
                        tupleGenericType(0),
                        tupleOfNullablesGenericType(0),
                        mutableTupleGenericType(0)
                    )
                )
                    .set(new ReferenceValueImpl("new "
                        + type.eval(
                            tupleImplementationSimpleName(degree),
                            tupleOfNullablesImplementationSimpleName(degree),
                            mutableTupleImplementationSimpleName(degree)
                        )
                        + "()"))
                    .public_().static_().final_()
            );
            constructor.private_();
        } else {
            constructor.public_();
        }
        final Javadoc javaDocConstructor = Javadoc.of(
            "Constructs a {@link " + type.eval("Tuple", "TupleOfNullables", "MutableTuple") + "} of type {@link " + type.eval(tupleSimpleName(degree), tupleOfNullablesSimpleName(degree), mutableTupleSimpleName(degree)) + "}.");
        if (!isMutable) {
            IntStream.range(0, degree).forEachOrdered(parameter -> {
                javaDocConstructor.add(PARAM.setValue(elementName(parameter)).setText("element " + parameter));
                final Type parameterType = SimpleType.create(genericTypeName(parameter));
                constructor.add(Field.of(elementName(parameter), parameterType));
            });
        }
        constructor.set(javaDocConstructor);
        constructor.add(
            "super("
            + Stream.concat(
                Stream.of(getClassName() + ".class"),
                isMutable ? Stream.of(Integer.toString(degree)) : IntStream.range(0, degree).mapToObj(TupleUtil::elementName)
            ).collect(joining(", "))
            + ");"
        );

        clazz.add(constructor);

        IntStream.range(0, degree)
            .mapToObj(this::getterMethod)
            .forEachOrdered(clazz::add);

        if (isMutable) {
            IntStream.range(0, degree)
                .mapToObj(this::setterMethod)
                .forEachOrdered(clazz::add);
        }

        return clazz;
    }

    private Method getterMethod(int index) {
        final Type genericType = SimpleType.create(genericTypeName(index));
        return Method.of("get" + index, type.eval(genericType, optional(genericType), optional(genericType)))
            .public_()
            .add(SUPPRESS_WARNINGS_UNCHECKED)
            .add(OVERRIDE)
            .add("return "
                + type.eval(
                    "((" + genericTypeName(index) + ")",
                    "Optional.ofNullable((" + genericTypeName(index) + ")",
                    "Optional.ofNullable((" + genericTypeName(index) + ")"
                )
                + " values[" + index + "]);");
    }

    private Method setterMethod(int index) {
        final Type genericType = SimpleType.create(genericTypeName(index));
        final String parameterName = genericType.getTypeName().toLowerCase();
        return Method.of("set" + index, void.class)
            .public_()
            .add(OVERRIDE)
            .add(Field.of(parameterName, genericType))
            .add("values[" + index + "] = " + parameterName + ";");
    }

}
